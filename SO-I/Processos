Conceitos:{
	-Um sistema operacional executa uma variedade de programas ou tarefas de usu√°rios.
	-Process: Representa√ß√£o de programas ou tarefas em execu√ß√£o pelo SO(De forma simples: Um programa em execu√ß√£o)
	-SOs modernos permitem a execu√ß√£o CONCORRENTE de v√°rios processos(processos compartilham o tempo da CPU)
	-A principal tarefa do SO √© ESCALONAR(definir o momento em que cada processo √© executado na linha do tempo) a execu√ß√£o de v√°rios processos para uma ou poucas CPUs.
}

--------------------------------------------------------------------------------
Estados de um Processo:{

	-Para organizar a execu√ß√£o de varios processos, o SO controla o estado deste conforme sua execu√ß√£o.
	-Cada processo pode estar em um dos seguintes estados:{
		-novo: O processo est√° sendo criado.
		-executando: O processo est√° aesperando a ocorr√™ncia de algum evento(ex:I/O)//esperando algo para ELE utilizar.
		-pronto: O processo est√° esperando para ser atribu√≠do a algum processador.//est√° esperando a vez dele de executar.Esperando a batata chegar na m√£o dele.
		-terminado: O processo terminou sua execu√ß√£o.
		//ver ilustra√ß√£o de processos no slide do dia 22/09/21
	}
}

--------------------------------------------------------------------------------
Bloco de Controle de Processo(PCB/Process Control Block):{
	//O sistema operacional salva informa√ß√µes dos processos.
	//O PCB √© um registro que o sistema operacional faz para cada processo, cada um tem um PCB, como uma ficha de um paciente no hospital.

	-Representa√ß√£o de um processo no sistema. Um PCB mant√©m muitas informa√ß√µes associadas a um processo:{
		-Estado do processo(ex:novo, executando, etc.)
		-Contador do programa(end da pr√≥xima instru√ß√£o)//quando um processo for interrompido, ele pode voltar a executar de onde parou.
		-Registradores da CPU(armazena o conte√∫do dos registradores quando o processo for interrompido)
		-Informa√ß√µes de escalonamento de processo(ex: prioridade, ponteiros de filas de escalonamento)
		-Informa√ß√µes de gerenciamento de mem√≥ria.
		-Informa√ß√µes de contabiliza√ß√£o(quando, onde).
		-Informa√ß√µes de status de I/O(ex: lista de dispositivos de I/O alocados)
	}
}

--------------------------------------------------------------------------------
Escalonamento de Processos:{
	-O objetivo da multiprograma√ß√£o √© ter processos em execu√ß√£o o tempo todo(maximizar a utiliza√ß√£o da CPU)
	-Em um sistema com um processador:{
		-Nunca haver√° mas de um processo em execu√ß√£o.
		-Se houver mais processos, os demais ter√£o que esperar at√© que a CPU seja liberada e possa ser reescalonada.
	}
	-Para compartilhar a CPU, √© desej√°vel alternar entre processos de forma frequente(Para que os usu√°rios possam interagir com cada programa durante sua execu√ß√£o)
}

--------------------------------------------------------------------------------
Escalonamento de Processos:{
	-Caracter√≠stica de um processo:Ciclo de surtos de CPU e I/O{
		-Propriedade observada nos processos: a execu√ß√£o de um processo consiste de um ciclo de execu√ßao na CPU e espera de I/O, alternando entre esses dois estados.
		-Esperas nos processos oportunizam a utiliza√ß√£o da CPU para execu√ß√£o de outros processos prontos!//enquanto um processos faz I/O, o SO executa partes de outros processos enquanto a CPU est√° dispon√≠vel.
	}
}

--------------------------------------------------------------------------------
Principais Componentes:{
	-Filas de escalonamento:{
		-Fun√ß√£o: Organizar os v√°rios processos em execu√ß√£o.
		-Tipos:{
			-Fila de processos pronto: conjuntos de todos os processos residentes em mem√≥ria principal, prontos e esperando serem executados pela CPU.
			-Fila de dispositivo ou fila de espera: conjunto de processos esperando para acessar um dispositivo. Cda dispositivo tem sua pr√≥pria fila.
		}
	}
	-Escalonador(Scheduler):Seleciona processos prontos para a execu√ß√£o na CPU
	-Executor(Dispatcher): D√° controle da CPU ao processo selecionado pelo escalonador.	
}
---------------------------------------------------------------------------------
Ciclo de Vida de Processos:{
	-Um processo novo inicailmente È colocado na fila de processos prontos. ELe espera na fila atÈ ser selecionado para execuÁ„o pelo ESCALONADOR.//mas quem realmente executa o processo È o EXECUTOR(DISPATCHER)
	-Depois que o processo est· em execuÁ„o, um dos eventos abaixo pode ocorrer:{
		-O processo pode emitir um pedido de I/O e ser colocado na fila de I/O.
		-O processo pode ser removido ‡ forÁa da CPU, como resultado de uma interrupÁ„o ou porque seu tempo expirou.
		-O processo pode criar um subprocesso e esperar seu tÈrmino.
	}
	-Um processo continua seu ciclo atÈ terminar, assim, È removido de todas as filas, seu PCB e recursos s„o desalocados.
	-Quando a CPU muda para outro processo, o SO deve salvar o etado do processo antigo e carregar o estado do novo.
	-O contexto de um processo È representado no seu PCB.
	-Troca de contexto È um overhead para o sistema, j· que ele n„o pode fazer nada ˙til durante a troca.
}
---------------------------------------------------------------------------------
Modelos de Escalonamento:{
	-Escalonamento preemptivo e n„o-preemptivo:{
		-N„o preemptivo: SÛ ocorre o escalonamento de processos quando o que estiver em execuÁ„o terminar ou passar para o estado de espera (ex: I/O)//Comum nos SOs multitarefa antigos, como o Windows 3.1
		-Preemptivo: Pode ocorrer o escalonamento de processos em qualquer situaÁ„o, ou seja, devido auma interrupÁ„o pelo SO, conclus„o do processo, ou I/O.//Comum a todos os SOs atuais. A vantagem È que um processo n„o prejudica a execuÁ„o de outros.
	}
}

--------------------------------------------------------------------------------
Alfgoritmos de Escalonamento:{
	-N„o necessariamente os processos devem ser executados na ordem da fila de processos pronos.
	-Alguns critÈrios podem ser avaliados para a escolha de qual processo executar:{
		-A ordem da fila: Menor tempo de espera na fila de prontos.
		-Menor Job Primeiro: Menor tempo de resposta.
		-Por prioridade: Leva em consideraÁ„o a import‚ncia do processo.
		-Outros.
	}
	-Algoritmos:{
		-FCFS(n„o preemptivo)
		-Por prioridade(n„o preemptivo)
		-Round Robin(FCFS preemptivo)
	}
	-Algoritmo de FCFS(First Come, first served), ou FIFO:{
		-Algoritmo n„o-preemptivo simples onde o processo que solicitar primeiro a CPU ser· o primeiro a ser atendido.
		-Ex: Sejam os processos, em ordem, p1, p2 e p3.{
			p1: duraÁ„o do surto de CPU = 24 ms
			p2: duraÁ„o ... = 3 ms
			p3: ... = 3 ms

			Tempo mÈdio de espera(tme) = tempo para ser atendido / quantidade de processos
			T(p1) = 0
			T(p2) = 24
			T(p3) = 27
			Tme = (0 + 24 + 27)/3 = 51/3 = 17 ms 			
			Ele vai executar na ordem de chegada, p1 primeiro, depois p2 e entao p3.
		}
	}
	-Algoritmo SJF(Shortest Job First){
		-Ordena os processos de forma crescente, ou seja, passa os menores pra frente //igual uma fila de prioridade
		
		T(p1) = 6
		T(p2) = 3
		T(p3) = 0
		Tme = (0 + 3 + 6)/3 = 9/3 = 3 ms

		-O problema do SJF È saber exatamente o tamanho do surto de CPU de cada processo previamente.
	}
	-Algoritmo de escalonamento por prioridade:{
		-Uma prioridade È associada a cada proccesso, e a CPU È alocada ao processo com prioridade mais alta.
		-N˙meros menores representam prioridades maiores.

		-Ex: 
			p1 = 10 ms = prioridade 3
			p2 = 1 ms  = prioridade 1
			p3 = 2 ms  = prioridade 4
			p4 = 1 ms  = prioridade 5
			p5 = 5 ms  = prioridade 2

			Tme = (0 + 1 + 6 + 16 + 18) / 5 = 41 / 5 = 8.2ms
		-Prioridade podem ser estabelecidads por caracterÌsticas internas(requisitos de memÛria, arquivos abertos, surto de CPU mÈdio, etc) ou externas(import‚ncia do processo, etc) ao SO.
		-Pode ocorres starvation(estagnaÁ„o), quando processos de prioridade baixa ficam esperando indefinidamente para serem executados. A soluÁ„o È o aumento da prioridade conforme o processo envelhece (aging)//Esse È o utilizado nos sistemas operacionais modernos.

	}
}
